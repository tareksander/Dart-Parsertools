

import 'package:parser_builder2_runtime/parser_builder2_runtime.dart';

/// The type of parser that should be generated.
enum ParserType {
  /// Generates an LALR(1) parser if no shift/reduce or reduce/reduce conflicts occur.
  // ignore: constant_identifier_names
  LALR1,

  /// Generates a canonical LR(1) parser if no shift/reduce or reduce/reduce conflicts occur.
  // ignore: constant_identifier_names
  LR1,
  /// Generates a GLR parser.
  // ignore: constant_identifier_names
  GLR,
}

/// Declares a class as a parser to generate code for.
class Parser {
  /// The starting symbol of the grammar.
  final String startSymbol;
  /// The type of parser generated.
  final ParserType type;
  /// The semantic value of the start token, and what the parse method returns.
  final Type rootValue;
  /// The type of the terminal tokens passed to the parse method.
  /// Has to be a subclass of [TerminalSymbol].
  final Type terminalSymbol;

  /// Declares a class as a parser to generate code for.
  /// [startSymbol] is a string identifying the starting symbol of the grammar.
  /// [type] is the generated parser type.
  /// [rootValue] is the value the parse method returns.
  /// [terminalSymbol] is the type the parse method accepts, and has to be a subclass of [TerminalSymbol].
  const Parser({required this.startSymbol, required this.type, required this.rootValue, required this.terminalSymbol});
}



/// Makes a method be called as the action to compute the semantic value of a rule.
class ParserRule {
  /// The non-terminal symbol generated by the rule.
  final String nonterminal;
  /// The symbols that can be reduced to the non-terminal symbol.
  final List<String> symbols;
  
  /// Creates a rule for reducing [symbols] to [nonterminal].
  const ParserRule(this.nonterminal, this.symbols);
}




